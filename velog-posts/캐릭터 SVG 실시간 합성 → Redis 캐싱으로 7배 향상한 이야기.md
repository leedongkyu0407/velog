<h2 id="🐱-프로젝트-소개-솔브냥">🐱 프로젝트 소개: <a href="https://www.solve-nyang.com">솔브냥</a></h2>
<blockquote>
<p><strong>Solvenyang</strong>은 알고리즘 문제를 풀면서 고양이 캐릭터를 수집하고, 이를 조합해 나만의 <strong>커스텀 프로필 이미지</strong>를 만드는 게이미피케이션 기반 알고리즘 학습 서비스입니다.</p>
</blockquote>
<p>사용자는 선택한 캐릭터, 배경 외에도 다음과 같은 정보를 SVG 이미지에 포함시킬 수 있습니다:</p>
<ul>
<li>현재 티어</li>
<li>푼 문제 수</li>
<li>연속 풀이 일수</li>
<li>사용자가 직접 정한 문구 (ex: &quot;GithubID&quot;)</li>
</ul>
<p>이 모든 정보가 반영된 캐릭터가 움직이는 <strong>동적 SVG</strong>를 생성해, 외부 블로그나 포트폴리오에 쉽게 임베딩할 수 있도록 설계했습니다.</p>
<hr />
<h2 id="⏰-문제-상황-실시간-합성-서버-터진다">⏰ 문제 상황: 실시간 합성? 서버 터진다...</h2>
<p>해당 이미지는 사용자가 변경하지 않는 한 반복적으로 동일합니다.
하지만 우리 서비스는 사용자가 해당 이미지를 불러올 때마다 매번 다음 과정을 수행했습니다.</p>
<ol>
<li>DB에서 캐릭터, 배경, 유저 통계 정보 조회</li>
<li>SVG 레이어 파일들 불러오기</li>
<li>동적으로 텍스트, 이미지 레이어 조합 → 최종 SVG 생성</li>
<li>SVG 문자열 응답 반환</li>
</ol>
<p>이 방식은 유연하고 확장성은 좋았지만, 이미지를 단 한 번 요청할 때도 꽤 많은 리소스를 소모했고, 유입량이 늘어나면서 서버 부하로 이어졌습니다.
게다가 이 이미지는 외부 사이트(블로그, GitHub README 등)에 img 태그로 자주 삽입되기 때문에, 매우 자주 호출되는 API이기도 했습니다.</p>
<hr />
<h2 id="🔁-캐싱-전에-먼저-한-일-svg-리소스-메모리-선로딩">🔁 캐싱 전에 먼저 한 일: SVG 리소스 메모리 선로딩</h2>
<p>Redis 캐싱을 도입하기 전에, 먼저 <strong>SVG 합성 속도 자체를 빠르게 하기 위한 노력</strong>을 했습니다.</p>
<p>이를 위해 <strong>SVG 리소스를 서버 메모리에 미리 로딩해두는 방식</strong>을 사용했습니다.</p>
<blockquote>
<p>고양이 캐릭터, 배경, 티어, 숫자/문자 등 수많은 SVG 파일을
서버 실행 시 <code>SvgResources</code> 라는 컴포넌트에 전부 읽어 들여,
매 요청마다 파일 I/O를 하지 않고 <strong>메모리에서 바로 가져다 쓰도록</strong> 개선했습니다.</p>
</blockquote>
<p>이 구조 덕분에 <strong>합성 연산의 속도는 빨라졌지만</strong>,
문제는 여전히 “매번 합성을 한다는 점” 이었고,
결국 <strong>동일한 사용자에게 반복적으로 응답되는 SVG는 Redis로 캐싱</strong>하는 방식까지 도입하게 되었습니다.</p>
<hr />
<h2 id="💡-redis-캐싱으로-실시간-합성-최소화">💡 Redis 캐싱으로 실시간 합성 최소화</h2>
<p>앞서 말했듯이 SVG를 조합하는 요소들은 대부분 <strong>자주 바뀌지 않는 값들</strong>이었습니다.
따라서, <strong>변경이 감지되지 않으면 기존 SVG를 그대로 재사용하는 구조</strong>로 개선하면 된다고 생각했습니다.</p>
<blockquote>
<p>즉, 실시간 생성 대신
<strong>“캐싱된 SVG가 있으면 그걸 주자”</strong>는 전략으로 리팩토링을 진행했습니다.</p>
</blockquote>
<h3 id="🧱-캐싱-구조-설계">🧱 캐싱 구조 설계</h3>
<ul>
<li><strong>Key</strong>: <code>user:profile:image:{userId}</code></li>
<li><strong>Value</strong>: 최종 SVG 문자열</li>
<li><strong>TTL</strong>: <strong>12시간</strong> (사용자가 자주 바꾸지 않기 때문에 긴 캐싱도 가능했음)</li>
</ul>
<h4 id="🌀-흐름-변경-전-vs-후">🌀 흐름 변경 전 vs 후</h4>
<table>
<thead>
<tr>
<th>단계</th>
<th>개선 전</th>
<th>개선 후</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>DB에서 모든 정보 조회</td>
<td>Redis 캐시 조회</td>
</tr>
<tr>
<td>2</td>
<td>이미지, 텍스트 합성 수행</td>
<td>캐시 hit 시 생략</td>
</tr>
<tr>
<td>3</td>
<td>SVG 문자열 응답 반환</td>
<td>동일</td>
</tr>
</tbody></table>
<blockquote>
<p>만약 캐시가 없거나 사용자가 커스터마이징을 변경한 경우엔,
기존 로직대로 실시간 합성을 수행하고 Redis에 새로 저장합니다.</p>
</blockquote>
<hr />
<h3 id="🛠️-적용-결과">🛠️ 적용 결과</h3>
<p><strong>평균 응답 시간이 1.5초 이상 → 200ms 이하 수준으로 감소, 약 7배 이상 성능 향상</strong>
실시간 SVG 생성 횟수 대폭 감소
외부 <code>img</code> 태그에서 호출되는 API 응답 속도 안정화</p>
<hr />
<h3 id="🤔-느낀-점">🤔 느낀 점</h3>
<p>이 개선 작업은 단순히 “빠르게 만들자”에서 출발했지만, 그 과정을 거치며
<strong>&quot;과연 이걸 매번 새로 만드는 게 필요한가?&quot;</strong>라는 질문으로 확장되었습니다.</p>
<p>외부 블로그나 GitHub README에 삽입된 이미지가 느리게 뜨는 건 사용자 경험에 직접적인 영향을 주기 때문에,
빠른 응답 속도는 필수 조건이었습니다. 하지만 그 속도를 무작정 높이기보다는,
불필요한 작업 자체를 없애는 구조를 만드는 게 더 근본적인 해결책이라는 걸 깨달았습니다.</p>
<p>빠르게 하기 위한 노력은 당연했고,
결국 진짜 중요한 건 <strong>“안 해도 되는 걸 반복하지 않는 구조”</strong>였습니다.</p>
<p>이번 경험을 통해 성능 개선은 단순한 기술 적용이 아니라,
사용자 관점에서 출발해 문제의 본질을 찾아가는 과정이라는 걸 배웠습니다.</p>